<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js - pointerlock controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }
        
        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }
        
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        #instructions {
            width: 100%;
            height: 100%;
            display: -webkit-box;
            display: -moz-box;
            display: box;
            -webkit-box-orient: horizontal;
            -moz-box-orient: horizontal;
            box-orient: horizontal;
            -webkit-box-pack: center;
            -moz-box-pack: center;
            box-pack: center;
            -webkit-box-align: center;
            -moz-box-align: center;
            box-align: center;
            color: #ffffff;
            text-align: center;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <script src="js/three.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/LoaderSupport.js"></script>
    <script src="js/OBJLoader.js"></script>
    <script src="js/OBJLoader2.js"></script>
    <div id="blocker">

        <div id="instructions">
            <span style="font-size:40px">Click to start</span>
            <br /> (W, A, S, D = Move, MOUSE = Look around)
        </div>

    </div>

    <script>
        var camera, scene, renderer, controls;

        var objects = [];

        var raycaster;

        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');

        // http://www.html5rocks.com/en/tutorials/pointerlock/intro/

        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

        if (havePointerLock) {

            var element = document.body;

            var pointerlockchange = function(event) {

                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {

                    controlsEnabled = true;
                    controls.enabled = true;

                    blocker.style.display = 'none';

                } else {

                    controls.enabled = false;

                    blocker.style.display = 'block';

                    instructions.style.display = '';

                }

            };

            var pointerlockerror = function(event) {

                instructions.style.display = '';

            };

            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

            instructions.addEventListener('click', function(event) {

                instructions.style.display = 'none';

                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();

            }, false);

        } else {

            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

        }

        init();
        animate();

        var controlsEnabled = false;

        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        var canJump = false;

        var prevTime = performance.now();
        var velocity = new THREE.Vector3();
        var direction = new THREE.Vector3();

        function init() {

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            //scene.fog = new THREE.Fog(0xffffff, 0, 750);

            var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            controls = new THREE.PointerLockControls(camera);
            scene.add(controls.getObject());

            var onKeyDown = function(event) {

                switch (event.keyCode) {

                    case 38: // up
                    case 87: // w
                        moveForward = true;
                        break;

                    case 37: // left
                    case 65: // a
                        moveLeft = true;
                        break;

                    case 40: // down
                    case 83: // s
                        moveBackward = true;
                        break;

                    case 39: // right
                    case 68: // d
                        moveRight = true;
                        break;

                    case 32: // space
                        if (canJump === true) velocity.y += 350;
                        canJump = false;
                        break;

                }

            };

            var onKeyUp = function(event) {

                switch (event.keyCode) {

                    case 38: // up
                    case 87: // w
                        moveForward = false;
                        break;

                    case 37: // left
                    case 65: // a
                        moveLeft = false;
                        break;

                    case 40: // down
                    case 83: // s
                        moveBackward = false;
                        break;

                    case 39: // right
                    case 68: // d
                        moveRight = false;
                        break;

                }

            };

            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

            // floor

            var floorGeometry = new THREE.PlaneGeometry(2000, 2000, 1, 1);
            floorGeometry.rotateX(-Math.PI / 2);

            for (var i = 0, l = floorGeometry.vertices.length; i < l; i++) {

                var vertex = floorGeometry.vertices[i];
                //vertex.x += Math.random() * 20 - 10;
                //vertex.y += Math.random() * 2;
                //vertex.z += Math.random() * 20 - 10;

            }

            for (var i = 0, l = floorGeometry.faces.length; i < l; i++) {

                var face = floorGeometry.faces[i];
                face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);

            }

            var floorMaterial = new THREE.MeshBasicMaterial({
                vertexColors: THREE.VertexColors
            });

            var floor = new THREE.Mesh(floorGeometry, floorMaterial);
            scene.add(floor);

            // objects

            var boxGeometry = new THREE.BoxGeometry(20, 20, 20);

            for (var i = 0, l = boxGeometry.faces.length; i < l; i++) {

                var face = boxGeometry.faces[i];
                face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);

            }

            for (var i = 0; i < 4; i++) {

                var boxMaterial = new THREE.MeshPhongMaterial({
                    specular: 0xffffff,
                    flatShading: true,
                    vertexColors: THREE.VertexColors
                });
                boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75);

                var box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.x = (Math.floor(i * 20) + (i * 3)) - 35;
                box.position.y = 22;
                box.position.z = 20; //Math.floor(Math.random() * 20 - 10) * 20;

                scene.add(box);
                objects.push(box);
                //
            }

            //

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls.getObject().translateY(75);
            controls.getObject().translateZ(-150);
            controls.getObject().rotation.y = 3.142;
            //
            var loader = new THREE.OBJLoader2();

            // function called on successful load
            var callbackOnLoad = function(event2) {
                //event2.detail.loaderRootNode.rotation.y = 3.142;

                //event2.detail.loaderRootNode.translateZ(100);
                scene.add(event2.detail.loaderRootNode);
            };

            // load a resource from provided URL synchronously
            loader.load('model/eb_metal_shelf_01/eb_metal_shelf_01.obj', callbackOnLoad, null, null, null, false);


            var onProgress = function(xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };
            var onError = function(xhr) {};

            //var mtlLoader = new THREE.MTLLoader();
            //mtlLoader.setPath('model/factory/');
            //mtlLoader.load('factory_building_2.mtl', function(materials) {

            var callbackOnLoad2 = function(event) {

                //event.detail.loaderRootNode.Scale = new Vector(1.1, 1.1, 1.1);
                scene.add(event.detail.loaderRootNode);
            };

            //loader.setMaterials(materials);
            //loader.setPath('model/house/');
            // load a resource from provided URL synchronously
            loader.load('model/factory/factory_building_2.obj', callbackOnLoad2, null, null, null, false);
            /*
                materials.preload();
                var objLoader = new THREE.OBJLoader2();
                objLoader.setMaterials(materials);
                objLoader.setPath('model/factory/');
                objLoader.load('factory_building_2.obj', function(object) {
                    //object.position.y = - 95;
                    scene.add(object);
                },null, null, null, false);
            });
*/
            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            if (controlsEnabled === true) {

                raycaster.ray.origin.copy(controls.getObject().position);
                raycaster.ray.origin.y -= 10;

                var intersections = raycaster.intersectObjects(objects);

                var onObject = intersections.length > 0;

                var time = performance.now();
                var delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveLeft) - Number(moveRight);
                direction.normalize(); // this ensures consistent movements in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 800.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 800.0 * delta;

                if (onObject === true) {

                    velocity.y = Math.max(0, velocity.y);
                    canJump = true;

                }

                controls.getObject().translateX(velocity.x * delta);
                controls.getObject().translateY(velocity.y * delta);
                controls.getObject().translateZ(velocity.z * delta);

                if (controls.getObject().position.y < 75) {

                    velocity.y = 0;
                    controls.getObject().position.y = 75;

                    canJump = true;

                }

                prevTime = time;

            }

            renderer.render(scene, camera);

        }
    </script>
</body>

</html>